[{"content":"Inclusion is a process and practice that involves enabling people of all identities, orientations, and styles to be fully themselves while also contributing to the larger collective, as valued and full members. The question that often cannot be easily answered is this whether free speech is fully compatible with diversity, inclusion, and equality?\nIn light of that, here\u0026rsquo;s a poem I wrote inspired by a recent experience:\n In the land of diversity and inclusion\nIn a sea of different and tolerant people\nThere is that one quiet voice\nDrowned in collective representations\nDenied of individual expression\nI hope my friend\nYou will choose to be\nThe one to lend\nA listening ear\nAnd seek to understand\nBefore being understood\nAnd opt to disagree\nBut still appreciate\nThey have a story\nYet to be told\n My hope is that at some point we will find a way to recognize, appreciate, and acknowledge the contradictions inherent in inclusion and use the resulting tensions as springboards to push us forward and closer not backwards and further apart.\nThank you for reading.\n","date":"2022-04-29T15:18:21Z","permalink":"https://www.chingono.com/blog/2022/04/29/the-paradox-of-inclusion/","title":"The Paradox of Inclusion"},{"content":"Back in 2013, I created a nice little sample project demonstrating code generation among other things. Scott Hanselman had this to say about it:\nReally col http://t.co/dzTs3fnv \u0026quot;Northwind\u0026quot; demo app by @achingono on GitHub. Clever use of T4 and more. Starred! https://t.co/1GTE055f\n\u0026mdash; Scott Hanselman 🇺🇦 (@shanselman) January 9, 2013  I really enjoyed code generation with T4 in Visual Studio that I used it in all my projects. Four years later, I asked the following on Twitter:\n@mkristensen @VisualStudio is there an equivalent to T4Scaffolding for #dotnercore? I need to generate multiple files based on a template.\n\u0026mdash; Alfero Chingono (@achingono) December 1, 2017  Glenn von Breadmeister was kind enough to respond with:\nNot really no. At least not one that I am aware of. People like @anurse will tell you that you can use razor. But afaik there isnt anything quite like t4.\n\u0026mdash; Glenn von Breadmeister (@condrong) December 1, 2017  And Andrew Stanton-Nurse took it further by saying:\nRazor isn’t for generating anything other than HTML. My understanding is that T4Scaffolding generates code, which Razor is really bad at. I don’t think there’s a good replacement right now\n\u0026mdash; Andrew Stanton-Nurse (@anurse) December 5, 2017  I somewhat forgot about these conversations until recently when I started building another sample project and needed to generate some code for rapid development. Looking around, I couldn\u0026rsquo;t find something that suited my needs and besides, I had a lingering question: \u0026ldquo;Is razor really that bad at code generation?\u0026rdquo;. I figured maybe it\u0026rsquo;s worth a try.\nSo, I created a dotnet global tool for generating project files.\n\ndotnet-spawn is a roslyn-based code generator for dotnet that adds files to a project or solution. Code generation parameters can be supplied inline or from a response file. At this time dotnet-spawn is able to create a single file or multiple files of any extension based on a Razor file template.\nHow To Use Invoking the dotnet spawn command will generate project files based on the supplied parameters or response file. You can control how verbose the output will be by using the --verbosity option.\nCommand Options  --project: The path to the project or solution file to analyze with Roslyn --template: The path to the template file used for code generation --output: The path to a file/folder. If the tool is generating a single file, then the path should be a file, otherwise, it should be a folder. --namespace: The namespace used for generated files, if applicable. This parameter is available in the Razor template and can be customized further. --generator: One of SingleFile or MultipleFile. As the names suggest, the SingleFile generator creates a single file and the MultipleFile generator creates multiple files. --match: The lambda expression representing the Roslyn symbols that should be used for code generation. --pattern: The lambda expression used by the MultipleFile generator to generate file names. --verbosity: Set the verbosity level. Allowed values are Debug, Info, and Quiet.  The Help Option This tool provides an option to display a brief description of the available commands, options, and arguments. System.CommandLine automatically generates help output. For example:\n1  dotnet spawn --help   produces the following output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  Description: Roslyn based code generator. Usage: dotnet-spawn [options] Options: -p, --project \u0026lt;project\u0026gt; (REQUIRED) Project file, Solution file or directory -t, --template \u0026lt;template\u0026gt; (REQUIRED) Specify the template used for the generated code file(s) -g, --generator \u0026lt;generator\u0026gt; (REQUIRED) Specify the generator used for the generated code file(s) -n, --namespace \u0026lt;namespace\u0026gt; (REQUIRED) Specify the namespace for the generated code file(s) -m, --match \u0026lt;match\u0026gt; Specify the lambda expression used for the nanes of the generated code file(s) -p, --pattern \u0026lt;pattern\u0026gt; Specify the lambda expression used for the nanes of the generated code file(s) -o, --output \u0026lt;output\u0026gt; (REQUIRED) Specify the file or folder used for the generated code file(s) [default: .] -v, --verbosity \u0026lt;Debug|Info|Quiet\u0026gt; Output verbosity [default: Info] -f, --force Force execution of command --version Show version information -?, -h, --help Show help and usage information   Response File A response file is a file that contains a set of tokens for a command-line app. Response files are a feature of System.CommandLine that is useful in two scenarios:\n To invoke a command-line app by specifying input that is longer than the character limit of the terminal. To invoke the same command repeatedly without retyping the whole line. To use a response file, enter the file name prefixed by an @ sign wherever in the line you want to insert commands, options, and arguments. The following lines are equivalent:  1  dotnet spawn @controllers.rsp   Contents of controllers.rsp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  --project ./src/Sample.sln --template ./src/Sample/Templates/Controller.cshtml --output ./src/Sample/Controllers --namespace Sample.Controllers --generator MultipleFile --match symbol =\u0026gt; symbol.IsReferenceType \u0026amp;\u0026amp; !(symbol.IsAbstract || symbol.IsNamespace || symbol.IsVirtual) --pattern model =\u0026gt; $\u0026#34;{model.Name}.cs\u0026#34; --verbosity Info   How To Install You can install the latest build of the tool using the following command.\n1  dotnet tool install -g dotnet-spawn   How To Uninstall You can uninstall the tool using the following command.\n1  dotnet tool uninstall -g dotnet-spawn   ","date":"2022-04-10T14:31:58Z","image":"https://www.chingono.com/blog/2022/04/10/dotnet-spawn-global-tool/cover_hu66dd2538423f2960887539a786eeed4f_16336_120x120_fill_q75_box_smart1.jpg","permalink":"https://www.chingono.com/blog/2022/04/10/dotnet-spawn-global-tool/","title":"Dotnet Spawn Global Tool"},{"content":"A favicon, which is an abbreviation of the word \u0026ldquo;favorite icon\u0026rdquo;, is a small icon that helps users visually identify and distinguish your website. Its main purpose is to help visitors locate your page easier when they have multiple tabs, bookmarks, shortcuts, and address bars open.\nWith so many platforms, devices, icon formats, and dimensions, it\u0026rsquo;s hard to know exactly what you should do to consistently present your website icon/brand everywhere. That\u0026rsquo;s the reason why there are multiple favicon generators available. Just a quick search for \u0026ldquo;favicon generator\u0026rdquo; will reveal a long list of websites that assist in creating favicons supported across a wide range of platforms, and devices.\nThe one I chose for this case was favicon.io. This process could\u0026rsquo;ve been accomplished with realfavicongenerator.net just as well.\nAll I had to do was take a cropped version of my profile picture. It\u0026rsquo;s important that the picture be square, by the way. Then uploaded it to favicon.io and out came a zip file with everything I needed. Once downloaded, I extracted the zip file and copied the contents to the \u0026ldquo;static\u0026rdquo; folder of my Hugo site:\nThe next step was to simply copy the HTML snippet generated on the download page and paste it into layouts/partials/head/custom.html\n1 2 3 4  \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;180x180\u0026#34; href=\u0026#34;/apple-touch-icon.png\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/png\u0026#34; sizes=\u0026#34;32x32\u0026#34; href=\u0026#34;/favicon-32x32.png\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/png\u0026#34; sizes=\u0026#34;16x16\u0026#34; href=\u0026#34;/favicon-16x16.png\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;manifest\u0026#34; href=\u0026#34;/site.webmanifest\u0026#34;\u0026gt;   And that was it! I hope you find this post valuable, dear reader. All comments and feedback greatly appreciated.\nReferences:\nAdd favicon in config.toml · Issue #42\n","date":"2022-03-27T18:39:35Z","image":"https://www.chingono.com/blog/2022/03/27/adding-favicon-hugo-site/cover_hu2c8cb4ef37481515eef505f57d1e84e9_50792_120x120_fill_box_smart1_3.png","permalink":"https://www.chingono.com/blog/2022/03/27/adding-favicon-hugo-site/","title":"Add Favicon to a Hugo-Based Website"},{"content":"Now that I have custom tasks for building and serving my Hugo site in Visual Studio Code, I wanted to create posts quickly without having to remember the hugo command. So, this is what I did:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;New Post\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;title=\\\u0026#34;${input:title}\\\u0026#34; \u0026amp;\u0026amp; slug=\\\u0026#34;${title// /-}\\\u0026#34; \u0026amp;\u0026amp; hugo new content/post/${slug,,}/index.md --source ./src\u0026#34;, \u0026#34;problemMatcher\u0026#34;: [] } ], \u0026#34;inputs\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;title\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Enter the title of the new post\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;promptString\u0026#34; } ] }   The Variable Substitution section of the Visual Studio docs provides information on getting input from the user.\nFirst, I defined the inputs by providing the id, description, and type. Then the most interesting part:\nThe command:\n1  title=\u0026#34;${input:title}\u0026#34; \u0026amp;\u0026amp; slug=\u0026#34;${title// /-}\u0026#34; \u0026amp;\u0026amp; hugo new content/post/${slug,,}/index.md --source ./src   does three (3) things using bash:\n  Save the input text into a variable named title\n1  title=\u0026#34;${input:title}\u0026#34;     Replace spaces in the title variable with dashes and store the output in another variable named slug:\n1  slug=\u0026#34;${title// /-}\u0026#34;     Execute hugo command to create the content file:\n1  hugo new content/post/${slug,,}/index.md --source ./src   This last command converts the contents of the slug variable to lowercase. Pretty neat!\n  So far I\u0026rsquo;m pretty pleased with my experience with the Hugo static site generator.\n","date":"2022-03-17T18:39:12Z","image":"https://www.chingono.com/blog/2022/03/17/defining-task-quickly-creating-hugo-posts-vscode/cover_hub8e99cfaeac9e6974b03f6aa110414f0_82550_120x120_fill_q75_box_smart1.jpg","permalink":"https://www.chingono.com/blog/2022/03/17/defining-task-quickly-creating-hugo-posts-vscode/","title":"Defining A Task for Quickly Creating Hugo Posts In Visual Studio Code"},{"content":"Now that I can run the site locally, I needed a quick way to run the hugo command for creating new blog posts. After quick search on the internet, I found the article Tasks in Visual Studio Code very helpful. In short, I had to define the build task this way:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;Build\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;hugo --source ./src\u0026#34;, \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true } } ] }   This task executes the hugo command which generates your website to the public/ directory by default and makes it ready to be deployed to your web server. The --source argument ensures the correct folder is built. In addition, setting \u0026quot;kind\u0026quot;: \u0026quot;build\u0026quot; and \u0026quot;isDefault\u0026quot;: true ensures that this task is executed with the Ctrl+Shift+Bkeyboard shortcut.\nNext, I added another task to run the site locally:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;Build\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;hugo --source ./src\u0026#34;, \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true } }, { \u0026#34;label\u0026#34;: \u0026#34;Serve\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;hugo server -D --source ./src\u0026#34;, \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34; }, \u0026#34;isBackground\u0026#34;: true, \u0026#34;problemMatcher\u0026#34;: [] } ] }   This task executes the hugo server command. The -D flag ensures that we can preview content in draft mode, and again, the --source argument ensures the correct folder is served. It\u0026rsquo;s important to note that the Serve does not have \u0026quot;isDefault\u0026quot;: true since we do not want the two tasks to conflict when using the Ctrl+Shift+Bkeyboard shortcut.\nSo far I\u0026rsquo;m pretty pleased with my experience with the Hugo static site generator.\n","date":"2022-03-16T20:44:03Z","image":"https://www.chingono.com/blog/2022/03/16/defining-tasks-quickly-building-serving-hugo-site/cover_hu853181193b62abd8fd8dded5a69822fd_43411_120x120_fill_q75_box_smart1.jpg","permalink":"https://www.chingono.com/blog/2022/03/16/defining-tasks-quickly-building-serving-hugo-site/","title":"Defining Tasks for Quickly Building and Serving a Hugo Site"},{"content":"  Clone repo in Codespaces\n  Add Hugo devcontainer\n Click the \u0026ldquo;Codespaces\u0026rdquo; button in the bottom-left corner of Visual Studio Code Click \u0026ldquo;Add Development Container Configuration Files\u0026rdquo; Click \u0026ldquo;Show All Definitions\u0026rdquo; Click \u0026ldquo;Hugo (Community)\u0026rdquo; Click \u0026ldquo;OK\u0026rdquo;    Create new hugo site:\n1  \u0026gt;hugo new site blog     Try to create new hugo module https://docs.stack.jimmycai.com/getting-started\n1 2  \u0026gt;hugo mod init github.com/achingono/achingono.github.io Error: failed to init modules: binary with name \u0026#34;go\u0026#34; not found     Add go binary to devcontainer docker file\n1 2 3 4 5 6 7 8 9 10  # GO versionARG GO_VERSION=18 #Download GoRUN wget https://golang.org/dl/go1.${GO_VERSION}.linux-amd64.tar.gz \u0026amp;\u0026amp; \\  tar -C /usr/local -xzf go1.${GO_VERSION}.linux-amd64.tar.gz \u0026amp;\u0026amp; \\  rm go1.${GO_VERSION}.linux-amd64.tar.gzENV GOPATH /goENV PATH $GOPATH/bin:/usr/local/go/bin:$PATH    Check go version\n1 2  \u0026gt;go version go version go1.18 linux/amd64     Turn new site into a Hugo module:\n1 2 3 4  \u0026gt;hugo mod init github.com/achingono/achingono.github.io go: creating new go.mod: module github.com/achingono/achingono.github.io go: to add module requirements and sums: go mod tidy     Declare the hugo-theme-stack module as a dependency of your site:\n1 2 3 4  \u0026gt;hugo mod get github.com/CaiJimmy/hugo-theme-stack/v3 go: downloading github.com/CaiJimmy/hugo-theme-stack/v3 v3.10.0 go: downloading github.com/CaiJimmy/hugo-theme-stack v2.6.0+incompatible go: added github.com/CaiJimmy/hugo-theme-stack/v3 v3.10.0     Grab config file from example site\n1  \u0026gt;wget https://raw.githubusercontent.com/CaiJimmy/hugo-theme-stack/master/exampleSite/config.yaml     Update config.yaml file\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  baseurl:https://achingono.github.iolanguageCode:en-ustheme:github.com/CaiJimmy/hugo-theme-stack/v3paginate:5title:Alfero Chingonolanguages:en:languageName:Englishtitle:Alfero Chingonoweight:1# Change it to your Disqus shortname before usingdisqusShortname:achingono# GA Tracking IDgoogleAnalytics:# Theme i18n support# Available values: en, fr, id, ja, ko, pt-br, zh-cn, zh-tw, es, de, nl, it, th, el, uk, arDefaultContentLanguage:en# Set hasCJKLanguage to true if DefaultContentLanguage is in [zh-cn ja ko]# This will make .Summary and .WordCount behave correctly for CJK languages.hasCJKLanguage:falsepermalinks:post:/blog/:slug/page:/:slug/...module:# uncomment line below for temporary local development of module# replacements: \u0026#34;github.com/CaiJimmy/hugo-theme-stack/v3 -\u0026gt; ../../hugo-theme-stack\u0026#34;imports:- path:github.com/CaiJimmy/hugo-theme-stack/v3disable:false  Delete config.toml file Create new post Run hugo server -D Browse to http://127.0.0.1:1313  ","date":"2022-03-15T00:00:00Z","image":"https://www.chingono.com/blog/2022/03/15/hugo-blog-powered-by-github-pages-codespaces/cover_hu5e91b4f7e7a4ba6ba63ef7778b07ef87_84336_120x120_fill_q75_box_smart1.jpg","permalink":"https://www.chingono.com/blog/2022/03/15/hugo-blog-powered-by-github-pages-codespaces/","title":"Hugo blog powered by GitHub Pages and GitHub Codespaces"},{"content":"This is a continuation from my previous posts; Dockerizing Blazor Wasm Application\nThe previous setup was a follows: One drawback of this setup was that both the SPA service and the API service had to expose ports in order to be accessible and the ports had to be different. I didn\u0026rsquo;t like that very much and for my learning purposes, I set out to figure out how to accomplish the following setup:\nThe first task was to figure out how to configure NGINX to forward requests to multiple back-end services on the same port. After much research, this is the nginx.conf I eventually came up with:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  worker_processes 1; events { worker_connections 1024; } http { sendfile on; upstream spa-service { server SPA_SERVICE; } upstream api-service { server API_SERVICE; } # https://www.bogotobogo.com/DevOps/Docker/Docker-Compose-Nginx-Reverse-Proxy-Multiple-Containers.php proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Host $server_name; server { listen PORT; location / { proxy_pass http://spa-service/; proxy_redirect off; } # https://stackoverflow.com/a/53354944 location ~* /Api/v1\\.0/(.*) { # https://stackoverflow.com/a/8130872 proxy_pass http://api-service/Api/v1.0/$1$is_args$args; proxy_redirect off; # https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/linux-nginx?view=aspnetcore-5.0 proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-Proto $scheme; } } }   The tricky part was to ensure that only traffic intended for the SPA service was routed there. Somehow, I could not get it to work using just the path directive. I had to resort to regex to get it to work.\nNext, I created a configure-environment.sh script very similar to the previous article:\n1 2 3 4 5 6 7  #!/bin/sh  # replace the placeholders in the nginx congfiguration file  # https://stackoverflow.com/a/23134318 sed -i -e \u0026#34;s|API_SERVICE|${API_SERVICE}|g\u0026#34; /etc/nginx/nginx.conf sed -i -e \u0026#34;s|SPA_SERVICE|${SPA_SERVICE}|g\u0026#34; /etc/nginx/nginx.conf sed -i -e \u0026#39;s/PORT/\u0026#39;\u0026#34;${PORT}\u0026#34;\u0026#39;/g\u0026#39; /etc/nginx/nginx.conf   Details of the configuration settings are clearly outlined in the referenced articles.\nNext, the Dockerfile:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  FROMnginx:alpine AS runtime# copy startup commandsCOPY configure-environment.sh /docker-entrypoint.d/RUN chmod +x /docker-entrypoint.d/configure-environment.sh# https://www.bogotobogo.com/DevOps/Docker/Docker-Compose-Nginx-Reverse-Proxy-Multiple-Containers.phpCOPY nginx.conf /etc/nginx/nginx.confENV SPA_SERVICE=spa:8080 ENV API_SERVICE=api:8080ENV PORT=8080 EXPOSE8080WORKDIR/home/site/wwwroot  Finally, the docker-compose.yml to tie it all together:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  # https://docs.docker.com/compose/compose-file/compose-file-v3/version:\u0026#34;3\u0026#34;services:proxy:build:context:.dockerfile:Dockerfileimage:business/proxy:latestcontainer_name:business-proxyenvironment:- SPA_SERVICE=spa:8080- API_SERVICE=api:8080# https://docs.docker.com/compose/startup-order/depends_on:- spa- apirestart:alwaysports:- 80:8080  References:\nDOCKER COMPOSE : NGINX REVERSE PROXY WITH MULTIPLE CONTAINERS\nHost ASP.NET Core on Linux with Nginx\n\u0026ldquo;proxy_pass\u0026rdquo; cannot have URI part in location given by regular expression\nHow can query string parameters be forwarded through a proxy_pass with nginx?\nEnvironment variable substitution in sed\n","date":"2021-05-25T21:43:26Z","permalink":"https://www.chingono.com/blog/2021/05/25/using-nginx-reverse-proxy-for-local-microservice-development/","title":"Using Nginx Reverse Proxy for Local Microservice Development"},{"content":"This is a continuation from my previous posts; Dockerizing Blazor Wasm Application and Waiting for Docker Service Container Port to Be Ready.\nOne of the main reasons I needed my application container to wait for the database container to be ready was because I needed to initialize and seed the database before launching the application. This created a significant, and somewhat unacceptable, delay in container startup which impacted local development experience and automated UI tests.\nI went on a quest to search for a solution to this problem and found out that Database engines such as MySQL support the ability to automatically restore database backups when creating a docker container. Surely, Microsoft SQL Server would have the same feature, right? Apparently, not. So I had no choice but to roll out my own solution, right? Right!\nNow that we agree on the legitimacy of my quest, here are the changes I made to my project.\nFirst, I created a entrypoint.sh bash script with the following contents:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  #!/bin/bash  # Adapted from: github.com/microsoft/mssql-docker/issues/11 # Launch MSSQL and send to background /opt/mssql/bin/sqlservr \u0026amp; pid=$! # Wait for it to be available echo \u0026#34;Waiting for MS SQL to be available ⏳\u0026#34; /opt/mssql-tools/bin/sqlcmd -l 30 -S localhost -h-1 -V1 -U sa -P $SA_PASSWORD -Q \u0026#34;SET NOCOUNT ON SELECT \\\u0026#34;YAY WE ARE UP\\\u0026#34; , @@servername\u0026#34; is_up=$? while [ $is_up -ne 0 ] ; do echo -e $(date) /opt/mssql-tools/bin/sqlcmd -l 30 -S localhost -h-1 -V1 -U sa -P $SA_PASSWORD -Q \u0026#34;SET NOCOUNT ON SELECT \\\u0026#34;YAY WE ARE UP\\\u0026#34; , @@servername\u0026#34; is_up=$? sleep 5 done LOG_FILE=output.log # check flag so that this is only done once on creation, # and not every time the container runs if [ ! -f \u0026#34;${SCRIPTS_PATH}/${LOG_FILE}\u0026#34; ]; then # Run every bash script in /var/opt/mssql/scripts # https://stackoverflow.com/a/49383879 for file in \u0026#34;${SCRIPTS_PATH}/\u0026#34;*.sh; do echo \u0026#34;Executing: ${file}\u0026#34; \u0026gt;\u0026gt; \u0026#34;${SCRIPTS_PATH}/${LOG_FILE}\u0026#34; if [ -x \u0026#34;$file\u0026#34; ]; then echo \u0026#34;Executing $file\u0026#34;; \u0026#34;$file\u0026#34; else # warn on shell scripts without exec bit echo \u0026#34;Ignoring $file, not executable.\u0026#34;; fi done # https://stackoverflow.com/a/49383879 for file in \u0026#34;${SCRIPTS_PATH}/\u0026#34;*.sql; do echo \u0026#34;Executing: ${file}\u0026#34; \u0026gt;\u0026gt; \u0026#34;${SCRIPTS_PATH}/${LOG_FILE}\u0026#34; if test -f \u0026#34;$file\u0026#34;; then echo \u0026#34;Executing $file\u0026#34;; /opt/mssql-tools/bin/sqlcmd -U sa -P $SA_PASSWORD -l 30 -e -i $file fi done echo \u0026#34;All scripts have been executed.\u0026#34; fi echo \u0026#34;Waiting for MS SQL(pid $pid) to terminate.\u0026#34; # trap SIGTERM and send same to sqlservr process for clean shutdown trap \u0026#34;kill -15 $pid\u0026#34; SIGTERM # Wait on the sqlserver process wait $pid   The script above does four main things:\n Start MSSQL engine in the background Wait for the engine to be ready for connections Execute scripts in a specified folder Cleanly shutdown the MSSQL process when the SIGTERM signal is received.  You may also notice that there are two loops through the files in the scripts folder. The first loop iterates over bash scripts while the second iterates over SQL scripts.\nNext, I created a script file that restores the database:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #!/bin/bash  if [ \u0026#34;${DATABASE}\u0026#34; == \u0026#34;\u0026#34; ]; then echo \u0026#34;\u0026#39;DATABASE\u0026#39; environment variable not set.\u0026#34; exit 0 fi BACKUP_FILE=/var/opt/mssql/backup/${DATABASE}.bak DATA_FILE=/var/opt/mssql/data/${DATABASE}.mdf LOG_FILE=/var/opt/mssql/data/${DATABASE}_log.ldf if test -f \u0026#34;${BACKUP_FILE}\u0026#34;; then echo \u0026#34;${BACKUP_FILE}found.\u0026#34; else echo \u0026#34;${BACKUP_FILE}not found.\u0026#34; exit 0 fi echo \u0026#34;Restoring database ${DATABASE}\u0026#34; /opt/mssql-tools/bin/sqlcmd \\  -S localhost -U sa -P ${SA_PASSWORD} \\  -Q \u0026#39;RESTORE DATABASE \u0026#39;${DATABASE}\u0026#39; FROM DISK = \u0026#34;\u0026#39;${BACKUP_FILE}\u0026#39;\u0026#34; WITH MOVE \u0026#34;\u0026#39;${DATABASE}\u0026#39;\u0026#34; TO \u0026#34;\u0026#39;${DATA_FILE}\u0026#39;\u0026#34;, MOVE \u0026#34;\u0026#39;${DATABASE}\u0026#39;_Log\u0026#34; TO \u0026#34;\u0026#39;${LOG_FILE}\u0026#39;\u0026#34;\u0026#39;   All this script does is check for a DATABASE environment variable and by convention, a backup file with a matching name in a specified folder. If both exist, then it executes a RESTORE DATABASE command.\nThen, I created a Dockerfile with the following contents:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  ARG DATABASE=Business ARG SCRIPTS_PATH=/var/opt/mssql/scriptsFROMmcr.microsoft.com/mssql/server:2019-latestARG DATABASEARG SCRIPTS_PATHCOPY --chown=mssql:mssql entrypoint.sh /binRUN chmod +x /bin/entrypoint.shRUN mkdir -p ${SCRIPTS_PATH}COPY --chown=mssql:mssql restore-database.sh ${SCRIPTS_PATH}RUN chmod +x ${SCRIPTS_PATH}/restore-database.shRUN mkdir -p /var/opt/mssql/backupCOPY --chown=mssql:mssql database.bak /var/opt/mssql/backupRUN mv /var/opt/mssql/backup/database.bak /var/opt/mssql/backup/${DATABASE}.bakENV DATABASE=${DATABASE}ENV SCRIPTS_PATH=${SCRIPTS_PATH}# https://docs.docker.com/compose/aspnet-mssql-compose/ENTRYPOINT [\u0026#34;/bin/entrypoint.sh\u0026#34;]  This Dockerfile basically copies three files into the base MSSQL container:\n entrypoint.sh restore-database.sh database.bak  Once those three files are copied to the right folders and made executable, the magic happens when the container is created.\nThe last step was to update the docker-compose.yml file with the following changes:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  data: - image: mcr.microsoft.com/mssql/server:2019-latest + build: + context: . + dockerfile: Dockerfile + image: business/data:latest + container_name: business-data  environment: - SA_PASSWORD=${SQL_PASSWORD} - ACCEPT_EULA=Y + - DATABASE=${SQL_DATABASE}  restart: unless-stopped ports: - 1433:1433   With those changes in place, the database container creation process was multiple times faster than before and my automated UI tests were happier for it.\nReferences:\nRestore a SQL Server database in a Linux Docker container\nBASH - FOR loop using LS and wildcard\n","date":"2021-04-21T10:20:50Z","image":"https://www.chingono.com/blog/2021/04/21/restore-database-on-container-start-up/cover_hua6d920ccffbe7712bb5e078193bdddf7_60920_120x120_fill_q75_box_smart1.jpg","permalink":"https://www.chingono.com/blog/2021/04/21/restore-database-on-container-start-up/","title":"Restore Database on Container Start Up"},{"content":"This is a continuation of my previous post; Waiting for Docker Service Container Port to Be Ready. After reading this article, I decided to build up on that codebase as a learning opportunity and add a Blazor WASM front-end to the .NET Core API already built.\nI will not repeat the process details as that is nicely outlined in the referenced article. What I will do here is share my version of the Dockerfile and the associated script and configuration file.\nSo, here\u0026rsquo;s my Dockerfile:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  # [Choice] .NET Core version: 5.0, 3.1, 2.1ARG VARIANT=5.0ARG PROJECT=Business.SpaARG CONFIG=Release # create build image from base SDK imageFROMmcr.microsoft.com/dotnet/sdk:${VARIANT} as build# https://github.com/moby/moby/issues/37345#issuecomment-400245466ARG PROJECT# Copy all the csproj files and restore to cache the layer for faster builds# https://github.com/dotnet/dotnet-docker/issues/1697#issuecomment-589420446COPY src/Business.Spa/Business.Spa.csproj ./src/Business.Spa/# restore nuget packagesWORKDIR/srcRUN dotnet restore# run publish commandFROMbuild as publish# https://github.com/moby/moby/issues/37345#issuecomment-400245466ARG PROJECTARG CONFIG# copy source filesCOPY src/ /src/# run the publish commandWORKDIR/src/${PROJECT}RUN dotnet publish -c ${CONFIG} -o /${CONFIG} --no-restore# create release image from base runtime imageFROMnginx:alpine AS runtimeARG CONFIGRUN apk update \\  \u0026amp;\u0026amp; apk add --no-cache openssh# copy startup commandsCOPY ./configure-environment.sh /docker-entrypoint.d/RUN chmod +x /docker-entrypoint.d/configure-environment.sh# copy the nginx configuration file# https://www.c-sharpcorner.com/article/dockerizing-blazor-wasm-application/COPY ./nginx.conf /etc/nginx/nginx.confENV BLAZOR_ENVIRONMENT=Staging ENV REST_URL=http://localhost:8081ENV PORT=8080 EXPOSE8080WORKDIR/home/site/wwwrootCOPY --from=publish /${CONFIG}/wwwroot .  You will notice that my Dockerfile does not have a CMD or ENTRYPOINT declaration. That is because the base image I\u0026rsquo;m using to host my application nginx:alpine already has a very nice feature where it automatically runs all scripts in the /docker-entrypoint.d/ folder and executes them before starting up nginx.\nThis allowed me to copy my configure-environment.sh to the /docker-entrypoint.d/ folder, make it executable and let the magic happen.\nHere\u0026rsquo;s my configure-environment.sh:\n1 2 3 4 5 6 7 8 9 10 11 12 13  #!/bin/sh  # The script replaces the Api.BaseAddress in the configuration file  # with environment values set for the container  # replace the placeholder in the blazor congfiguration file  # https://stackoverflow.com/a/23134318 sed -i -e \u0026#34;s|REST_URL|${REST_URL}|g\u0026#34; \u0026#34;/home/site/wwwroot/appsettings.${BLAZOR_ENVIRONMENT}.json\u0026#34; # replace the placeholders in the nginx congfiguration file  # https://github.com/dotnet/aspnetcore/issues/25152  sed -i -e \u0026#39;s/BLAZOR_ENVIRONMENT/\u0026#39;\u0026#34;${BLAZOR_ENVIRONMENT}\u0026#34;\u0026#39;/g\u0026#39; /etc/nginx/nginx.conf sed -i -e \u0026#39;s/PORT/\u0026#39;\u0026#34;${PORT}\u0026#34;\u0026#39;/g\u0026#39; /etc/nginx/nginx.conf   And finally, here\u0026rsquo;s my nginx configuration file:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  events { } http { include mime.types; types { application/wasm wasm; } server { # this will be replaced by the sed command in the configure-environment.sh script listen PORT; index index.html; # This will add the environment http header to the responses # https://github.com/dotnet/aspnetcore/issues/25152 add_header Blazor-Environment BLAZOR_ENVIRONMENT; location / { root /home/site/wwwroot; try_files $uri $uri/ /index.html =404; } } }   Credits:\nDockerizing Blazor WASM Application\ndocker-nginx/docker-entrypoint.sh\nlinux - Environment variable substitution in sed\nASP.NET Core Blazor environments\nBlazor WASM not loading appsettings.{environment}.json in Azure App Services\n","date":"2021-04-07T18:39:49Z","image":"https://www.chingono.com/blog/2021/04/07/dockerizing-blazor-wasm-application/cover_hu54647e4733936e0a413cf65fbe4dc5e0_77413_120x120_fill_q75_box_smart1.jpg","permalink":"https://www.chingono.com/blog/2021/04/07/dockerizing-blazor-wasm-application/","title":"Dockerizing Blazor Wasm Application"},{"content":"In my previous post; Combining ENTRYPOINT and CMD in a Dockerfile, I showed how I added reusability to my Dockerfile by combining ENTRYPOINT and CMD.\nTo take things further, I didn\u0026rsquo;t like how I still had to supply arguments to entrypoint.sh when those arguments were already available in the container as environment variables, so I eventually modified my Dockerfile this way:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  # [Choice] .NET Core version: 5.0, 3.1, 2.1ARG VARIANT=3.1ARG DB_SERVICE=db ARG DB_SERVICE_PORT=1433 ARG PROJECT=Business.Web# create a base runtime image with nodeFROMmcr.microsoft.com/dotnet/core/aspnet:${VARIANT} AS runtimeEXPOSE80EXPOSE443RUN curl -sL https://deb.nodesource.com/setup_10.x | bash -RUN apt-get install -y nodejs# create a base SDK image with nodeFROMmcr.microsoft.com/dotnet/core/sdk:${VARIANT} as sdkRUN curl -sL https://deb.nodesource.com/setup_10.x | bash -RUN apt-get install -y nodejs# copy source filesFROMsdk as buildCOPY src/ ./src# restore nuget packagesWORKDIR/srcRUN dotnet restore# run publish commandFROMbuild as publishRUN dotnet publish -c Release -o /release --no-restore# create release image from base runtime imageFROMruntime AS release# https://github.com/moby/moby/issues/37345#issuecomment-400245466ARG PROJECTENV ASSEMBLY=${PROJECT}.dllCOPY --from=publish /release .COPY entrypoint.sh /bin/COPY testconnection.sh /bin/RUN chmod +x /bin/entrypoint.shRUN chmod +x /bin/testconnection.shENTRYPOINT [ \u0026#34;/bin/entrypoint.sh\u0026#34; ]CMD [\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;dotnet $ASSEMBLY\u0026#34;]  Subtle change; the location of the entrypoint.sh changed to /bin/entrypoint.sh and the $DB_SERVICE as well as the $DB_SERVICE_PORT arguments are missing. So, how does my entrypoint.sh know which server to check for connections before running our startup command? Thanks for asking:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  #!/bin/bash set -e # check if the startup command has been provided if [ \u0026#34;$1\u0026#34; == \u0026#34;\u0026#34; ]; then echo \u0026#34;Startup command not set. Exiting\u0026#34; exit; fi # check if the $DB_SERVICE environment variable has been set if [ \u0026#34;$DB_SERVICE\u0026#34; == \u0026#34;\u0026#34; ]; then echo \u0026#34;Environment variable \u0026#39;DB_SERVICE_NAME\u0026#39; not set. Exiting.\u0026#34; exit; fi # check if the $DB_SERVICE_PORT environment variable has been set if [ \u0026#34;$DB_SERVICE_PORT\u0026#34; == \u0026#34;\u0026#34; ]; then echo \u0026#34;Environment variable \u0026#39;DB_SERVICE_PORT\u0026#39; not set. Exiting.\u0026#34; exit; fi echo \u0026#34;Testing connection to ${DB_SERVICE}:${DB_SERVICE_PORT}\u0026#34; until /bin/test-connection.sh $DB_SERVICE_NAME $DB_SERVICE_PORT; do \u0026gt;\u0026amp;2 echo \u0026#34;DB Service is starting up\u0026#34; sleep 1 done \u0026gt;\u0026amp;2 echo \u0026#34;DB Service is up - executing command: \u0026#39;$@\u0026#39;\u0026#34; # https://stackoverflow.com/a/3816747 exec \u0026#34;$@\u0026#34; exit 0   As you can see, I am reading environment variables in the bash script and I use all arguments to this script as the startup command. You may prefer it the other way, but I like it this way, and I hope you find this post valuable.\nAs always, all comments and feedback are greatly appreciated.\nCredits:\nHow to check if an environment variable exists and get its value?\n","date":"2021-03-23T18:08:25Z","image":"https://www.chingono.com/blog/2021/03/23/optimizing-dockerfile-startup-script-with-environment-variables/cover_hu79b5dba812486e751d6f5b1c2c232866_25286_120x120_fill_box_smart1_3.png","permalink":"https://www.chingono.com/blog/2021/03/23/optimizing-dockerfile-startup-script-with-environment-variables/","title":"Optimizing Dockerfile Startup Script With Environment Variables"},{"content":"In my previous post; Reference Build Arguments in Docker Startup Script, I showed how I added reusability to my Dockerfile by adding build arguments.\nThe docker builder CMD reference document states:\n If you would like your container to run the same executable every time, then you should consider using ENTRYPOINT in combination with CMD. See ENTRYPOINT.\nIf the user specifies arguments to docker run then they will override the default specified in CMD.\n So, after some fiddling around, I ended up with the following final version of my Dockerfile:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  # [Choice] .NET Core version: 5.0, 3.1, 2.1ARG VARIANT=3.1ARG DB_SERVICE=db ARG DB_SERVICE_PORT=1433 ARG PROJECT=Business.Web# create a base runtime image with nodeFROMmcr.microsoft.com/dotnet/core/aspnet:${VARIANT} AS runtimeEXPOSE80EXPOSE443RUN curl -sL https://deb.nodesource.com/setup_10.x | bash -RUN apt-get install -y nodejs# create a base SDK image with nodeFROMmcr.microsoft.com/dotnet/core/sdk:${VARIANT} as sdkRUN curl -sL https://deb.nodesource.com/setup_10.x | bash -RUN apt-get install -y nodejs# copy source filesFROMsdk as buildCOPY src/ ./src# restore nuget packagesWORKDIR/srcRUN dotnet restore# run publish commandFROMbuild as publishRUN dotnet publish -c Release -o /release --no-restore# create release image from base runtime imageFROMruntime AS release# https://github.com/moby/moby/issues/37345#issuecomment-400245466ARG PROJECTENV ASSEMBLY=${PROJECT}.dllCOPY --from=publish /release .COPY entrypoint.sh .COPY testconnection.sh .RUN chmod +x ./entrypoint.shRUN chmod +x ./testconnection.shENTRYPOINT [ \u0026#34;./entrypoint.sh\u0026#34; ]CMD [\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;$DB_SERVICE $DB_SERVICE_PORT dotnet $ASSEMBLY\u0026#34;]  Configuring it this way allows me to supply different arguments when running the container without having to specify entrypoint.sh every time. Small change, and I hope this proves helpful to you, dear reader. All comments and feedback will be greatly appreciated.\n","date":"2021-03-15T17:51:18Z","image":"https://www.chingono.com/blog/2021/03/15/dockerfile-combine-entrypoint-cmd/cover_hubb1745ac1c8ec556e18776479db3c0c5_28145_120x120_fill_box_smart1_3.png","permalink":"https://www.chingono.com/blog/2021/03/15/dockerfile-combine-entrypoint-cmd/","title":"Combining ENTRYPOINT and CMD in a Dockerfile"},{"content":"In my previous post; Waiting for Docker Service Container Port to Be Ready, I showed how I managed to delay container application code execution until another service is ready to accept tcp connections.\nIf this post, I\u0026rsquo;m going to improve on that solution and make it more reusable by adding environment variables to the the Dockerfile and to the docker-compose.yml.\nHere\u0026rsquo;s the updated Dockerfile:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  # [Choice] .NET Core version: 5.0, 3.1, 2.1ARG VARIANT=3.1ARG DB_SERVICE=db ARG DB_SERVICE_PORT=1433 ARG PROJECT=Business.Web# create a base runtime image with nodeFROMmcr.microsoft.com/dotnet/core/aspnet:${VARIANT} AS runtimeEXPOSE80EXPOSE443RUN curl -sL https://deb.nodesource.com/setup_10.x | bash -RUN apt-get install -y nodejs# create a base SDK image with nodeFROMmcr.microsoft.com/dotnet/core/sdk:${VARIANT} as sdkRUN curl -sL https://deb.nodesource.com/setup_10.x | bash -RUN apt-get install -y nodejs# copy source filesFROMsdk as buildCOPY src/ ./src# restore nuget packagesWORKDIR/srcRUN dotnet restore# run publish commandFROMbuild as publishRUN dotnet publish -c Release -o /release --no-restore# create release image from base runtime imageFROMruntime AS release# https://github.com/moby/moby/issues/37345#issuecomment-400245466ARG PROJECTENV DB_SERVICE=${DB_SERVICE}ENV DB_SERVICE_PORT=${DB_SERVICE_PORT}ENV ASSEMBLY=${PROJECT}.dllCOPY --from=publish /release .COPY entrypoint.sh .COPY testconnection.sh .RUN chmod +x ./entrypoint.shRUN chmod +x ./testconnection.shCMD [\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;./entrypoint.sh $DB_SERVICE $DB_SERVICE_PORT dotnet $ASSEMBLY\u0026#34;]  And the docker-compose.yml file:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  # https://docs.docker.com/compose/compose-file/compose-file-v3/version:\u0026#39;3\u0026#39;services:app:build:context:.dockerfile:Dockerfileargs:# [Choice] Update \u0026#39;VARIANT\u0026#39; to pick a .NET Core version: 2.1, 3.1, 5.0VARIANT:3.1DB_SERVICE:dbDB_SERVICE_PORT:1433PROJECT:Business.Webimage:business_webenvironment:- ASPNETCORE_ENVIRONMENT=Testing- ASPNETCORE_URLS=http://+:80- ASPNETCORE_ConnectionStrings__Db=Server=db;Database=Business.Web;User ID=sa;Password=V3ry$ecureP@ssw0rd;MultipleActiveResultSets=False;Connection Timeout=30;- DB_SERVICE=db- DB_SERVICE_PORT=1433# https://docs.docker.com/compose/startup-order/depends_on:- dbrestart:on-failureports:- \u0026#34;8080:80\u0026#34;- \u0026#34;8443:443\u0026#34;volumes:- ~/.aspnet/https:/https:ro db:image:mcr.microsoft.com/mssql/server:2019-latestrestart:unless-stoppedenvironment:- SA_PASSWORD=V3ry$ecureP@ssw0rd- ACCEPT_EULA=Y  With this setup, I can create multiple image variations with the same Dockerfile by supplying the three arguments:\n1 2 3  DB_SERVICE: db DB_SERVICE_PORT: 1433 PROJECT: Business.Web  And when I run the docker image, I can also supply the same three environment variables in order to override the container defaults. Hopefully this proves helpful to you, dear reader. All feedback will be greatly appreciated.\nCredits:\nPersisting ENV and ARG settings to all later stages in multi-stage builds\n","date":"2021-03-11T21:27:40Z","image":"https://www.chingono.com/blog/2021/03/11/reference-environment-variables-docker-startup-script/cover_hu5baa1151b514a27cf3a27c15e1c673f5_55131_120x120_fill_q75_box_smart1.jpg","permalink":"https://www.chingono.com/blog/2021/03/11/reference-environment-variables-docker-startup-script/","title":"Reference Environment Variables in Docker Startup Script"},{"content":"Recently, I was working on a pet project and had created my Dockerfile for the ASP.NET Core container as well as the docker-compose.yml file to compose the services.\nHere\u0026rsquo;s the Dockerfile I had:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  # [Choice] .NET Core version: 5.0, 3.1, 2.1ARG VARIANT=3.1# create a base runtime image with nodeFROMmcr.microsoft.com/dotnet/core/aspnet:${VARIANT} AS runtimeEXPOSE80EXPOSE443RUN curl -sL https://deb.nodesource.com/setup_10.x | bash -RUN apt-get install -y nodejs# create a base SDK image with nodeFROMmcr.microsoft.com/dotnet/core/sdk:${VARIANT} as sdkRUN curl -sL https://deb.nodesource.com/setup_10.x | bash -RUN apt-get install -y nodejs# copy source filesFROMsdk as buildCOPY src/ ./src# install npm packages#WORKDIR /src/Business.Web/Spa#RUN npm install#RUN npm run build# restore nuget packagesWORKDIR/srcRUN dotnet restore# run publish commandFROMbuild as publishRUN dotnet publish -c Release -o /release --no-restore# create release image from base runtime imageFROMruntime AS releaseCOPY --from=publish /release .ENTRYPOINT [\u0026#34;dotnet\u0026#34;, \u0026#34;Business.Web.dll\u0026#34;]  And the docker-compose.yml file:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  # https://docs.docker.com/compose/compose-file/compose-file-v3/version:\u0026#39;3\u0026#39;services:app:build:context:.dockerfile:Dockerfileargs:# [Choice] Update \u0026#39;VARIANT\u0026#39; to pick a .NET Core version: 2.1, 3.1, 5.0VARIANT:3.1image:business_webenvironment:- ASPNETCORE_ENVIRONMENT=Testing- ASPNETCORE_URLS=http://+:80- ASPNETCORE_ConnectionStrings__Db=Server=db;Database=Business.Web;User ID=sa;Password=V3ry$ecureP@ssw0rd;MultipleActiveResultSets=False;Connection Timeout=30;# https://docs.docker.com/compose/startup-order/depends_on:- dbrestart:on-failureports:- \u0026#34;8080:80\u0026#34;- \u0026#34;8443:443\u0026#34;volumes:- ~/.aspnet/https:/https:ro db:image:mcr.microsoft.com/mssql/server:2019-latestrestart:unless-stoppedenvironment:- SA_PASSWORD=V3ry$ecureP@ssw0rd- ACCEPT_EULA=Y  My biggest challenge was that even though I had set the app service to depend on the db service, the app service would start before the db service was really ready to receive connections. This resulted in .net startup errors, crash loops and the container eventually shutting down:\n1 2 3 4 5 6 7 8 9  info: Microsoft.EntityFrameworkCore.Infrastructure[10403] Entity Framework Core 3.1.3 initialized \u0026#39;DataContext\u0026#39; using provider \u0026#39;Microsoft.EntityFrameworkCore.SqlServer\u0026#39; with options: None crit: Microsoft.AspNetCore.Hosting.Diagnostics[6] Application startup exception Microsoft.Data.SqlClient.SqlException (0x80131904): A network-related or instance-specific error occurred while establishing a connection to SQL Server. The server was not found or was not accessible. Verify that the instance name is correct and that SQL Server is configured to allow remote connections. (provider: TCP Provider, error: 35 - An internal exception was caught) ---\u0026gt; System.Net.Internals.SocketExceptionFactory+ExtendedSocketException (00000001, 11): Resource temporarily unavailable   Since there was some initialization code and database seeding that had to take place before the application was ready to run, I wanted to ensure that the dotnet code started only when the database container/service was ready to receive connections.\nAfter some searching on the internet, I found this answer on the Unix StackExchange:\nTesting remote TCP port using telnet by running a one-line command\nNow, I needed to ensure this command runs before launching the .net site, and only after the db server was ready to receive connections on port 1433. So, after some further searching, trial and error, I eventually landed on the following two scripts:\ntestconnection.sh is a copy of the code found on Unix StackExchange:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #!/bin/bash # https://unix.stackexchange.com/a/406356 if [ \u0026#34;$2\u0026#34; == \u0026#34;\u0026#34; ]; then echo \u0026#34;Syntax: $0\u0026lt;host\u0026gt; \u0026lt;port\u0026gt;\u0026#34; exit; fi host=$1 port=$2 r=$(bash -c \u0026#39;exec 3\u0026lt;\u0026gt; /dev/tcp/\u0026#39;$host\u0026#39;/\u0026#39;$port\u0026#39;;echo $?\u0026#39; 2\u0026gt;/dev/null) if [ \u0026#34;$r\u0026#34; = \u0026#34;0\u0026#34; ]; then echo \u0026#34;$host$portis open\u0026#34; else echo \u0026#34;$host$portis closed\u0026#34; exit 1 # To force fail result in ShellScript fi   entrypoint.sh is the entry point of the container. It checks the tcp port for readiness then executes the command for the container when the tcp port is open:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  #!/bin/bash set -e # get the first two arguments server=$1 port=$2 # check if we have 3 or more arguments if [ \u0026#34;$3\u0026#34; == \u0026#34;\u0026#34; ]; then echo \u0026#34;Syntax: $0\u0026lt;host\u0026gt; \u0026lt;port\u0026gt; \u0026lt;command\u0026gt; [\u0026lt;arg\u0026gt;, \u0026lt;arg\u0026gt;, ...]\u0026#34; exit; fi # use the first two arguments to test the tcp connection echo \u0026#34;Testing connection to ${server}:${port}\u0026#34; until ./testconnection.sh $server $port; do \u0026gt;\u0026amp;2 echo \u0026#34;SQL Server is starting up\u0026#34; sleep 1 done \u0026gt;\u0026amp;2 echo \u0026#34;SQL Server is up - executing command\u0026#34; # https://stackoverflow.com/a/3816747 # use the rest of the arguments to start up the container exec \u0026#34;${@:3}\u0026#34;   Key points to note here are that entrypoint.sh uses the first two arguments for checking the tcp port and the rest of the arguments for container startup. So, instead of starting up our container this way:\n1  ENTRYPOINT [\u0026#34;dotnet\u0026#34;, \u0026#34;Business.Web.dll\u0026#34;]  We will use the following approach instead:\n1 2 3 4 5 6  COPY entrypoint.sh .COPY testconnection.sh .RUN chmod +x ./entrypoint.shRUN chmod +x ./testconnection.shCMD /bin/bash ./entrypoint.sh db 1433 dotnet Business.Web.dll  When the services are started with this new dockerfile, this is what I got in the logs:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  SQL Server is starting up SQL Server is starting up SQL Server is starting up SQL Server is starting up SQL Server is starting up SQL Server is up - executing command: \u0026#39;sh -c dotnet Business.Web.dll\u0026#39; Testing connection to data:1433 data 1433 is closed data 1433 is closed data 1433 is closed data 1433 is closed data 1433 is closed data 1433 is open info: Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager[64] Azure Web Sites environment detected. Using \u0026#39;/root/ASP.NET/DataProtection-Keys\u0026#39; as key repository; keys will not be encrypted at rest. warn: Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository[60] Storing keys in a directory \u0026#39;/root/ASP.NET/DataProtection-Keys\u0026#39; that may not be persisted outside of the container. Protected data will be unavailable when info: Microsoft.EntityFrameworkCore.Infrastructure[10403] Entity Framework Core 5.0.6 initialized \u0026#39;DataContext\u0026#39; using provider \u0026#39;Microsoft.EntityFrameworkCore.SqlServer\u0026#39; with options: None info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (22ms) [Parameters=[], CommandType=\u0026#39;Text\u0026#39;, CommandTimeout=\u0026#39;30\u0026#39;] SELECT 1   As you can see, this solution allowed my app container to wait for as long as it needed to before starting the .net application. Hopefully, you find that helpful, dear reader.\nCredits:\nTesting remote TCP port using telnet by running a one-line command\nHow to pass all arguments passed to my bash script to a function of mine?\n","date":"2021-03-04T12:21:28Z","image":"https://www.chingono.com/blog/2021/03/04/waiting-docker-service-container-port-ready/cover_hu62f23ae666e781c65386d17f3dc1416f_38807_120x120_fill_q75_box_smart1.jpg","permalink":"https://www.chingono.com/blog/2021/03/04/waiting-docker-service-container-port-ready/","title":"Waiting for Docker Service Container Port to Be Ready"}]